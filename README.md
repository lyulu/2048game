# プログラムの説明

## 注意事項

- `main_old.c`は無視してください。

- Github上だとなぜか1,2,3,...がa,b,c,...と表示されてしまうので、いい感じに読み取ってくださるとありがたいです。

- 出力行数が多少多いと思うので大きめのウインドウで遊んでもらえると嬉しいです。

## 採点基準のうち実装した(つもりの)もの

- **1~5全て**

## 各関数の説明

- `print_legend`(**L7〜50**) : 
    - 引数 : 上下左右方向の各移動可能フラグ、シャッフル可能フラグ、盤面隠しフラグを示す1つの`unsigned int`
    - 返り値 : なし
    - 機能 : 凡例(動かせる方向+シャッフル+盤面隠し+ゲーム終了)を表示する。
    - 挙動 : 各`printf`を参照。
    - アピールポイント : 
        - フラグを引数に取っているので、その時点で実行可能なキーしか表示されないようになっている。
        - 矢印も表示することで直感的にもどちらに動かすのかが分かりやすい凡例表記になっている。

- `print_board`(**L52〜78**) : 
    - 引数 : 盤面情報を保持した配列、盤面の一辺の大きさ、残りターン数、スコア、`print_legend`の引数でも用いたフラグ`unsigned int`
    - 返り値 : なし
    - 機能 : 各数字(盤面を隠している時には` ????? `)が書かれた盤面、残りターン数とスコアを表示。
    - 挙動 : こちらも各`printf`を参照。
    - アピールポイント :
        - 盤面を見やすくするために枠を用意した。
        - 数字の表示桁数を揃えることで(7文字分)、大きな数と小さな数が入り乱れても見やすいようにした。

- `random_generate`(**L80〜105**) : 
    - 引数 : 盤面情報を保持した配列、盤面の一辺の大きさ、ゲームモード
    - 返り値 : なし
    - 機能 : 乱数(時刻に応じてseed値を変更)を用いることで盤面内に1つだけ数字を新たに生成する。2または4が生成されるが、4は2に比べて20倍ほど生成されにくい。チャレンジモードの時は2,4を-2,-4に読み替える。(挙動のところでも同様。)
    - 挙動 :
        1. 新たな数が盤面に追加されたかどうかを記録するフラグ`is_generated`が0の間は盤面を何周もし続ける。(盤面の大きさは高々6*6マス程度なので計算量を気にする必要はあまりない。)
        2. 1.において、すでに数が入っている場合はパスし、数が何もない(0が入っている)場合は乱数を生成、その値に応じて、2を生成/4を生成/何も生成せず次に進む、のいずれか1つを行う。数を生成する時は、盤面を直接変更している。
        3. 2を生成/4を生成が行われた場合は`is_generated`を1とし、`while`ループを抜ける。
    - アピールポイント : 本家リスペクトの4生成を実装した。

- `move_check_u(d/l/r)`(**L107〜134**/**L136〜163**/**L165〜192**/**L194〜221**) : 
    - 引数 : 盤面情報を保持した配列、盤面の一辺の大きさ
    - 返り値 : 上(下/左/右)方向に動かすことが可能な場合は1、不可能な場合は0
    - 機能 : どこか1つの列(行)について、(0を除いて)隣り合って同じ数字がある、もしくは合成できなくても0があって1つでも動かすことができるならばその方向に動かすことが可能であり、それを判定する。
    - 挙動 : 以下は上下左右(と行列)を読み替えるだけなので1つのみについて書き記す。
        1. `i`列目に対して、1番上にある数を`tmp`とおく。
        2. `i`列目の`j`行目について、
            - 0であれば、`j`行目よりも下に2以上の数が存在すれば、上に動かすことができるので、返り値`r`を1としてループ終了。
            - 0でなければ、`j > 0`行目について、`tmp`(0を除いた直上の数を表している。)と比較し、同じならばそれと合体することができるので、`r`を1としてループ終了。
        3. `r`の初期値は0なので、上記で1となる以外は、上方向には移動不可として返されることになる。
    - アピールポイント: 特になし。関数を方向別に作って愚直に調べた。

- `move_u(d/l/r)`(**L223〜259**/**L261〜297**/**L299〜335**/**L337〜373**) : 
    - 引数 : 盤面情報を保持した配列、盤面の一辺の大きさ、スコアを表す整数(参照渡し)
    - 返り値 : なし
    - 機能 : 上(下/左/右)方向に盤面を実際に動かす。各列(行)ごとに動かす方向側から更新していって、隣り合ってたものが同じ数字なら合体し、足りなくなったところを0で埋めて帳尻を合わせていく。合体したものについて、合体してできた数の大きさだけスコアを加算する。
    - 挙動 : 以下は上下左右(と行列)を読み替えるだけなので1つのみについて書き記す。
        1. 移動後の盤面を一時的に記録しておく配列`tmpv`を用意する。中身は0で埋めておく。
        2. `i`列目に対してそれぞれ調べ上げていく。移動後の何行目に当たるのかを記録する`tmp`を用意する。また、同時に3つ以上の数を足し合わせてしまわないように、合成できるかどうかのフラグ`can_merge`を用意する。
        3. `i`列目の`j`行目について、
            - 0であれば、動くことで詰められるかそのままであり、`tmpv`の初期値も0にしてあるので、無視する。
            - 0でない場合、1番上の行であれば、移動せずそのまま居残る。`j > 0`行目であれば、`can_merge`が1で、その時点までの移動後の盤面の`i`列目の0を除いた1番下に位置する数(`tmpv`の`i`列目`tmp`行目)と一致するならば、数を合成し、できた数の大きさ分だけスコアを加算し、`can_merge`を0にする。(3つ以上の合成防止)。それ以外は`tmpv`の`i`列目`++tmp`行目に数をそのまま配置し、`can_merge`を1にする。(数が何も合成されてない状態に戻るので)
        4. `tmpv`の内容を引数の盤面本体に写す。(`for`二重ループになっている。)
    - アピールポイント : こちらも`move_check_u(d/l/r)`同様に特にないが、同じ数が3つ以上並んだ場合なども本家同様の動きになるはず。

- `shuffle`(**L375〜409**) : 
    - 引数 : 盤面情報を保持した配列、盤面の一辺の大きさ
    - 返り値 : なし
    - 機能 : 各要素ごとにシャッフル後の盤面に振り分けていく。振り分け方は乱数(時刻に応じてseed値を変更)で決まっている。
    - 挙動 :
        1. シャッフル後の盤面を一時的に記録しておく配列`tmpv`を用意する。シャッフルされてきたものがないことを示すために初期値は-1。
        2. シャッフル前の各盤面の要素ごとに(`i,j`の`for`二重ループ)、次はどこに移るのかを乱数で決定する。
        3. 各要素について、`random_generate`の時と似たような感じで、`is_shuffled`が0の間は`tmpv`を何周もする。(`k,l`の`for`二重ループ+`while`文)。
        4. `tmpv`の要素が-1でなければすでに他の数が移ってきているということなので無視し、-1であれば乱数の値に応じて移動先として確定/何もせず続行のいずれか1つを行い、移動先として確定したら`is_shuffled`を1として`while`文を抜け、次の要素へ移る。
    - アピールポイント : ~~盤面の大きさを制限しているので、計算量度外視した(とはいっても6^4の整数倍程度)楽なコードを書いた。~~

- `board_max`(**L411〜419**) : 
    - 引数 : 盤面情報を保持した配列、盤面の個数
    - 返り値 : 盤面内で最も大きい数
    - 機能 : 盤面内で最も大きな数を探し出す。
    - 挙動 : 盤面の全ての要素について`for`ループで見てまわり、現時点での最大値`m`(初期値-99999999)と比較する。今回の2048ゲームでは、2次元配列ではなく1次元配列で数を記録していることに注意する。
    - アピールポイント : よくあるような関数だと思うので何もなし。

## 全体(`main`関数)の動作説明

1. ゲームモードを選択して入力してもらう。(0または1で、その他のキーを押すと再度打ち直すように要求される。)(**L427〜444**)
    - 0 : ノーマルモード
        - 通常の2048ゲーム。
        - 盤面の大きさが大きいほど楽になる。
    - 1 : チャレンジモード
        - 操作方法は2048と同じ。
        - 最初の持ちスコアは1000点。
        - 盤面に負の数が生成されていくので、絶対値の大きな数を作っていくとどんどんスコアが減っていく。
        - スコアが0以下になってしまったらゲームオーバー。
        - それまでに盤面を動かせなくすることができればゲームクリア。
        - 要するにはやく詰ませられれば勝ちのゲーム。
        - 盤面の大きさが小さいほど楽になる。

2. 盤面の一辺のサイズを入力してもらう。(2〜6の間で、その他のキーを押すと再度打ち直すように要求される。)この後一旦`scanf`を使いたいので`system("/bin/stty cooked");`を入れてある。(**L445〜461**)

3. ターン数を入力してもらう。(`int`型の範囲内であればOK。ただし、最後にはEnterキーを押してもらう必要がある数字以外のキーを入力しても何とかなるようにはしてあるが、念のため入力ミスに気をつけて欲しい。)(**L462〜473**）

4. 盤面をランダムに生成し(**L481〜488**)、ゲームスタート。最初に生成される数の個数は、(1行の大きさ-1)個で、本家と少し違う。必要な変数を宣言している。(**L477〜479, L490〜495**)

5. 凡例通りにキーを打ってもらって盤面を動かす。(`'i', 'j', 'k', 'm', 's', 'g/h', '.'` キー)(**L500〜**)

6. 入力されたキーが`'i', 'j', 'k', 'm'`ならば、入力してもらった方向について動かせるかどうかを判定し(前回ループの9.による)、動かせるなら続行してスコアを加算し、新たな数をランダム生成し、ターン数を1減らす。動かせないなら、`You can't move.`を表示する。

7. 入力されたキーが`'s'`ならば、盤面をシャッフルする。シャッフルした時は新たな数は生成せず、シャッフルだけ行なった後、ターン数を5減らす。ターン数的にシャッフルできない時に`'s'`を押した時には`You can't shuffle.`を表示する。

8. 入力されたキーが`'h'`(盤面が隠されている時は`'g'`)ならば、盤面を隠す(表示する)。その他使用しないキーを押した時は`You pressed wrong key.`を表示する。(**〜L551**)

9. 盤面が動いたら、次の盤面がどの方向に動かせるのかをチェックする。どの方向にも動かせない場合は、これもまたゲームオーバーとする。(**ここで、シャッフル可能な残りターン数であっても、ゲームオーバーになってしまうことに注意。シャッフル後に移動不可能な盤面になったらゲームオーバーになることも注意。**)また、盤面内の最大の数、シャッフル可能性も更新する。(**L553〜562**)

10. 盤面を表示する。また、入力ミスがあった場合もそれを表示する。(**L564〜574**)

11. 盤面内の最大数が2048以上(1024 = 2 ^ 10よりも大きい)の場合、~~2048という名前のゲームなので一応~~クリア表記を出しておく。(**L576〜580**)

12. 残りターン数が0またはどの方向にも動けない場合はゲームオーバーとする。(**L582〜590**)

13. ゲームモードがチャレンジモードのとき、スコアが0以下になったらゲームオーバーとする。(**L591〜594**)

14. 以上の5.〜13.をゲームオーバーになるまで続ける。(`while`文に相当するループ)

15. 上記5.〜13.で`'.'`が押された場合や、ゲームオーバーになった後、`Game Over`を表示し、最終状況(盤面、残りターン数、スコア、クリアしたもの)を表示してプログラムを終了する。(**L597〜607**)

## 追加機能

- 盤面のサイズを決められるようにした。

- ゆるいターン制にした。

- 凡例のところで、実行可能なコマンドのみを表示することで、より簡単にプレイができるようにした。

- 盤面の枠と各数字の表示桁数を固定することで、見やすくした。

- 盤面シャッフル機能を追加した。

- 入力ミス指摘表示を充実(?)させた。

- 盤面を隠す機能を実装した。操作できる方向は凡例から分かるので、運ゲー(~~ク◯ゲー~~)として遊ぶことも可能になった。

- チャレンジモード（とそれに伴うモード選択）を実装した。
